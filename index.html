<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>AI Tag Battle - Final Showdown</title>
    <style>
        body { background: #111; color: #0f0; font-family: 'Courier New', monospace; margin: 0; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { background: #000; box-shadow: 0 0 20px rgba(0,255,0,0.2); }
        #overlay { position: absolute; text-align: center; background: rgba(0,0,0,0.8); padding: 20px; border: 2px solid #0f0; z-index: 10; }
        h1 { margin-top: 0; color: #fff; }
        button { cursor: pointer; padding: 15px 30px; margin: 10px; background: #222; color: #0f0; border: 2px solid #0f0; font-size: 1.2em; font-weight: bold; }
        button:hover { background: #0f0; color: #000; }
        #status { position: absolute; top: 10px; left: 10px; font-size: 1.2em; pointer-events: none; }
    </style>
</head>
<body>

    <div id="status">第622世代 AI対戦モード</div>

    <div id="overlay">
        <h1>AI Tag Battle</h1>
        <p>最強の第622世代AIに挑戦してください</p>
        <button onclick="startGame('chaser')">鬼として参戦 (赤)</button>
        <button onclick="startGame('evader')">逃走者として参戦 (水色)</button>
        <p style="font-size: 0.8em; color: #888;">操作: 矢印キーまたはWASD / スペースでワープ</p>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
    // --- インポートされたDNAデータ ---
    const STRONGEST_DNA = {
        chaser: [3.43117021140104,-4.08822794950183,1.5997219294828058,3.492633508119267,1.9687971278811431,-4.0461748569772595,-0.7327900089049664,-6.034486360456051,-0.5912457061984661,2.6691654766924016],
        evader: [-1.9910758066851977,3.8888530531368337,0.00031575008647713454,-2.9522593609555092,2.9048687559823962,-5.293882750058083,-3.433910451138047,3.6811625514056368,4.433049398304223,2.3996208432564496]
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    
    let playerRole = null;
    let gameActive = false;
    const keys = new Set();
    const FPS = 30;
    const WARP_DIST = 100; // 画面が広いので少し飛距離アップ

    window.addEventListener('keydown', e => { if(e.key === ' ') e.preventDefault(); keys.add(e.key.toLowerCase()); });
    window.addEventListener('keyup', e => keys.delete(e.key.toLowerCase()));

    class Agent {
        constructor(x, y, color, dna) {
            this.x = x; this.y = y;
            this.color = color;
            this.dna = dna;
            this.dirIndex = 0;
            this.warpCooldown = 0;
            this.warpLines = [];
        }
        get angle() { return this.dirIndex * (Math.PI / 2); }
    }

    let chaser, evader, frame;

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function startGame(role) {
        playerRole = role;
        overlay.style.display = 'none';
        chaser = new Agent(100, 100, '#ff4444', STRONGEST_DNA.chaser);
        evader = new Agent(canvas.width - 100, canvas.height - 100, '#00ffff', STRONGEST_DNA.evader);
        frame = 0;
        gameActive = true;
    }

    function getLogicalDir(ent, target, isChaser) {
        const dx = target.x - ent.x;
        const dy = target.y - ent.y;
        let preferredDirs = isChaser 
            ? (Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? [0, 1, 3, 2] : [2, 1, 3, 0]) : (dy > 0 ? [1, 0, 2, 3] : [3, 0, 2, 1]))
            : (Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? [2, 1, 3, 0] : [0, 1, 3, 2]) : (dy > 0 ? [3, 0, 2, 1] : [1, 0, 2, 3]));

        for (let dir of preferredDirs) {
            let nx = ent.x + Math.cos(dir * Math.PI/2) * 20;
            let ny = ent.y + Math.sin(dir * Math.PI/2) * 20;
            if (nx > 20 && nx < canvas.width-20 && ny > 20 && ny < canvas.height-20) return dir;
        }
        return preferredDirs[0];
    }

    function updateAgent(ent, target, isChaser) {
        let doWarp = false;
        const isPlayer = (playerRole === (isChaser ? 'chaser' : 'evader'));

        if (isPlayer) {
            if (keys.has('arrowright') || keys.has('d')) ent.dirIndex = 0;
            else if (keys.has('arrowdown') || keys.has('s')) ent.dirIndex = 1;
            else if (keys.has('arrowleft') || keys.has('a')) ent.dirIndex = 2;
            else if (keys.has('arrowup') || keys.has('w')) ent.dirIndex = 3;
            if (keys.has(' ')) doWarp = true;
        } else {
            ent.dirIndex = getLogicalDir(ent, target, isChaser);
            const dirFlags = [0,0,0,0]; dirFlags[ent.dirIndex] = 1;
            const inputs = [ent.x/canvas.width, ent.y/canvas.height, target.x/canvas.width, target.y/canvas.height, ...dirFlags, ent.warpCooldown === 0 ? 1 : 0, 0.5];
            let s = 0; for(let i=0; i<10; i++) s += inputs[i] * ent.dna[i];
            if (s > 1.5) doWarp = true;
        }

        if (doWarp && ent.warpCooldown === 0) {
            const ox = ent.x, oy = ent.y;
            ent.x += Math.cos(ent.angle) * WARP_DIST;
            ent.y += Math.sin(ent.angle) * WARP_DIST;
            ent.warpCooldown = 40;
            ent.warpLines.push({ x1: ox, y1: oy, x2: ent.x, y2: ent.y, life: 25 });
        } else {
            ent.x += Math.cos(ent.angle) * 8;
            ent.y += Math.sin(ent.angle) * 8;
        }
        ent.x = Math.max(10, Math.min(canvas.width-10, ent.x));
        ent.y = Math.max(10, Math.min(canvas.height-10, ent.y));
        if (ent.warpCooldown > 0) ent.warpCooldown--;
        ent.warpLines = ent.warpLines.filter(l => { l.life--; return l.life > 0; });
    }

    function loop() {
        if (!gameActive) { requestAnimationFrame(loop); return; }

        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; // 残像効果
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        updateAgent(chaser, evader, true);
        updateAgent(evader, chaser, false);

        [chaser, evader].forEach(ent => {
            ent.warpLines.forEach(l => {
                ctx.beginPath(); ctx.strokeStyle = `rgba(255, 255, 0, ${l.life / 25})`;
                ctx.lineWidth = 4; ctx.moveTo(l.x1, l.y1); ctx.lineTo(l.x2, l.y2); ctx.stroke();
            });
            ctx.fillStyle = ent.color;
            ctx.save();
            ctx.translate(ent.x, ent.y);
            ctx.rotate(ent.angle);
            ctx.fillRect(-10, -10, 25, 20);
            if (ent.warpCooldown === 0) {
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(-12, -12, 30, 24);
            }
            ctx.restore();
        });

        const dist = Math.hypot(chaser.x - evader.x, chaser.y - evader.y);
        if (dist < 20) {
            gameActive = false;
            setTimeout(() => {
                alert(playerRole === 'chaser' ? "捕まえた！あなたの勝ちです。" : "捕まった... AIの勝ちです。");
                overlay.style.display = 'block';
            }, 100);
        }

        requestAnimationFrame(loop);
    }

    loop();
    </script>
</body>
</html>
